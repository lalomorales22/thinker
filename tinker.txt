Tinker: a training API for researchers and developers
Tinker lets you focus on what matters in LLM fine-tuning â€“ your data and algorithms â€“ while we handle the heavy lifting of distributed training.

You write a simple loop that runs on your CPU-only machine, including the data or environment and the loss function. We figure out how to make the training work on a bunch of GPUs, doing the exact computation you specified, efficiently. To change the model you're working with, you only need to change a single string in your code.

Tinker gives you full control over the training loop and all the algorithmic details. It's not a magic black box that makes fine-tuning "easy". It's a clean abstraction that shields you from the complexity of distributed training while preserving your control.

Here's how the division of responsibilities works in practice:

You focus on	You write	We handle
ğŸ“Š Datasets and RL environments
Your custom training data	ğŸ’» Simple Python script
Runs on your CPU	âš¡ Efficient distributed training of large models
Llama 70B, Qwen 235B
ğŸ¯ Training logic
Your loss functions, training loop, and evals	ğŸ”§ API calls
forward_backward()
optim_step()
sample()
save_state()	ğŸ›¡ï¸ Reliability
Hardware failures handled transparently
Features
What the Tinker service currently supports:

Tinker lets you fine-tune open-weight models like the Qwen and Llama series, including large mixture-of-experts models like Qwen3-235B-A22B.
Tinker implements low-rank adaptation (LoRA) fine-tuning, not full fine-tuning. However, we believe that LoRA gives the same performance as full fine-tuning for many important use cases, especially in RL (see LoRA Without Regret).
You can download the weights of your trained model to use outside of Tinker, for example with your inference provider of choice.
A quick look at functionality
Tinker's main functionality is contained in a few key functions:

forward_backward: feed in your data and loss function, and we'll compute and accumulate the gradients for you.
optim_step: update your model using the accumulated gradients
sample: Generate outputs from your trained model
other functions for saving and loading weights and optimizer state
Getting started with training and sampling
In this guide, we'll step you through using the Tinker Python library to do the basic operations needed for training and sampling. View the complete Python script â†’

Creating the training client
The main object we'll be using is the TrainingClient, which corresponds to a fine-tuned model that we can train and sample from.

First, set your Tinker API key environment variable. In the terminal where you'll run Python, or in your .bashrc, put export TINKER_API_KEY=<your key>.

Then, create a ServiceInterface. This lets you find out what base models are available to be fine-tuned.

import tinker
service_client = tinker.ServiceClient()
print("Available models:")
for item in service_client.get_server_capabilities().supported_models:
    print("- " + item.model_name)

You'll see a list of model names:

- meta-llama/Llama-3.1-70B
- meta-llama/Llama-3.1-8B
...
- Qwen/Qwen3-235B-A22B-Instruct-2507
- Qwen/Qwen3-30B-A3B-Base

We currently support models from the Qwen3 and Llama3 series. We're going to use Qwen3-30B-A3B-Base (a raw pre-trained model) for these examples. See Available Models in Tinker for the full list.

Now we can create the TrainingClient:

base_model = "Qwen/Qwen3-30B-A3B-Base"
training_client = service_client.create_lora_training_client(
    base_model=base_model
)

Note that we've specified a base model, which is the model we'll initialize from. In this case, it's a raw pre-trained model, but most of the "base models" in Tinker are fine-tuned for chat/instruction-following. You should check the details of the model you're using in their system cards.

Preparing the training data
Now we can do training updates on the model. This quickstart example won't show best practices for LLM fine-tuning; it's just an API demo. Check out Rendering, Supervised Fine-tuning and the other Cookbook examples for guidance on how to use Tinker in real applications.

For this model, we'll train a model that can translate words into Pig Latin. The rules for Pig Latin are simple:

If a word begins with a consonant, move it to the end and add "ay"
If a word begins with a vowel, just add "way" to the end
Here are some example completions we'd like the model to perform, where the prompt is in green and the model's completion is in red:

English: hello world
Pig Latin: ello-hay orld-way
Let's create some training examples and convert them to a format expected by Tinker.

# Create some training examples
examples = [
    {
        "input": "banana split",
        "output": "anana-bay plit-say"
    },
    {
        "input": "quantum physics",
        "output": "uantum-qay ysics-phay"
    },
    {
        "input": "donut shop",
        "output": "onut-day op-shay"
    },
    {
        "input": "pickle jar",
        "output": "ickle-pay ar-jay"
    },
    {
        "input": "space exploration",
        "output": "ace-spay exploration-way"
    },
    {
        "input": "rubber duck",
        "output": "ubber-ray uck-day"
    },
    {
        "input": "coding wizard",
        "output": "oding-cay izard-way"
    },
]
 
# Convert examples into the format expected by the training client
from tinker import types
 
# Get the tokenizer from the training client
tokenizer = training_client.get_tokenizer()
 
def process_example(example: dict, tokenizer) -> types.Datum:
    # Format the input with Input/Output template
    # For most real use cases, you'll want to use a renderer / chat template,
    # (see later docs) but here, we'll keep it simple.
    prompt = f"English: {example['input']}\nPig Latin:"
 
    prompt_tokens = tokenizer.encode(prompt, add_special_tokens=True)
    prompt_weights = [0] * len(prompt_tokens)
    # Add a space before the output string, and finish with double newline
    completion_tokens = tokenizer.encode(f" {example['output']}\n\n", add_special_tokens=False)
    completion_weights = [1] * len(completion_tokens)
 
    tokens = prompt_tokens + completion_tokens
    weights = prompt_weights + completion_weights
 
    input_tokens = tokens[:-1]
    target_tokens = tokens[1:] # We're predicting the next token, so targets need to be shifted.
    weights = weights[1:]
 
    # A datum is a single training example for the loss function.
    # It has model_input, which is the input sequence that'll be passed into the LLM,
    # loss_fn_inputs, which is a dictionary of extra inputs used by the loss function.
    return types.Datum(
        model_input=types.ModelInput.from_ints(tokens=input_tokens),
        loss_fn_inputs=dict(weights=weights, target_tokens=target_tokens)
    )
 
processed_examples = [process_example(ex, tokenizer) for ex in examples]
 
# Visualize the first example for debugging purposes
datum0 = processed_examples[0]
print(f"{'Input':<20} {'Target':<20} {'Weight':<10}")
print("-" * 50)
for i, (inp, tgt, wgt) in enumerate(zip(datum0.model_input.to_ints(), datum0.loss_fn_inputs['target_tokens'].tolist(), datum0.loss_fn_inputs['weights'].tolist())):
    print(f"{repr(tokenizer.decode([inp])):<20} {repr(tokenizer.decode([tgt])):<20} {wgt:<10}")

The visualization of the first example is:

Input                Target               Weight
--------------------------------------------------
'English'            ':'                  0.0
':'                  ' I'                 0.0
' I'                 ' love'              0.0
' love'              ' tink'              0.0
' tink'              'ering'              0.0
'ering'              '\n'                 0.0
'\n'                 'P'                  0.0
'P'                  'ig'                 0.0
'ig'                 ' Latin'             0.0
' Latin'             ':'                  0.0
':'                  ' I'                 1.0
' I'                 '-way'               1.0
'-way'               ' o'                 1.0
' o'                 've'                 1.0
've'                 '-l'                 1.0
'-l'                 'ay'                 1.0
'ay'                 ' ink'               1.0
' ink'               'ering'              1.0
'ering'              '-t'                 1.0
'-t'                 'ay'                 1.0
'ay'                 '<|endoftext|>'      1.0

Performing a training update
Now we can use this data to perform a training update. We'll do 6 updates on the same batch of data. (Note that this is not typically a good way to train!)

import numpy as np
for _ in range(6):
    fwdbwd_future = training_client.forward_backward(processed_examples, "cross_entropy")
    optim_future = training_client.optim_step(types.AdamParams(learning_rate=1e-4))
 
    # Wait for the results
    fwdbwd_result = fwdbwd_future.result()
    optim_result = optim_future.result()
 
    # fwdbwd_result contains the logprobs of all the tokens we put in. Now we can compute the weighted
    # average log loss per token.
    logprobs = np.concatenate([output['logprobs'].tolist() for output in fwdbwd_result.loss_fn_outputs])
    weights = np.concatenate([example.loss_fn_inputs['weights'].tolist() for example in processed_examples])
    print(f"Loss per token: {-np.dot(logprobs, weights) / weights.sum():.4f}")

Note that the forward_backward and optim_step functions immediately return futures, which acknowledge that the task has been queued up by the server. For improved speed, we submitted both operations before waiting for the result by calling result() on the futures.

Sampling from the model
Now we can test our model by sampling from it. In this case, we'll translate the phrase "coffee break" into Pig Latin.

# First, create a sampling client. We need to transfer weights
sampling_client = training_client.save_weights_and_get_sampling_client(name='pig-latin-model')
 
# Now, we can sample from the model.
prompt = types.ModelInput.from_ints(tokenizer.encode("English: coffee break\nPig Latin:"))
params = types.SamplingParams(max_tokens=20, temperature=0.0, stop=["\n"]) # Greedy sampling
future = sampling_client.sample(prompt=prompt, sampling_params=params, num_samples=8)
result = future.result()
print("Responses:")
for i, seq in enumerate(result.sequences):
    print(f"{i}: {repr(tokenizer.decode(seq.tokens))}")

Since sampling is nondeterministic (sadly, even with temperature=0.0, due to batching), the output will be different each time. You should see something like this:

Responses:
0: ' offe-bay eak-bay\n\n'
1: ' offey-coy eak-bray\n\n'
2: ' offecay eakbray\n\n'
3: ' offeec-cay eak-brcay\n\n\n'
4: ' offecay akebay\n\n'
5: ' offee-Cay ake-bay\n\n\n'
6: ' offey-pay eak-bray\n\n'
7: ' offee â€“ cay eak â€“ bray\n\n'

Computing logprobs for a sequence
We can use the sampler to compute logprobs for a given sequence as well. This uses the prefill step and is returned as prompt logprobs.

prompt = types.ModelInput.from_ints(tokenizer.encode("How many r's are in the word strawberry?"))
sample_response = sampling_client.sample(
    prompt=prompt,
    num_samples=1,
    sampling_params=tinker.SamplingParams(max_tokens=1),  # Must be at least 1 token, represents prefill step
    include_prompt_logprobs=True,
).result()
 
# example: [None, -9.54505, -1.64629, -8.81116, -3.50217, -8.25927, ...]
print(sample_response.prompt_logprobs)

The first logprob is None (corresponding to the first token), and subsequent entries are logprobs of each token in the prompt.

The sampling client also has a helper function, which is the same as above:

sampling_client.compute_logprobs(prompt).result()

Top-k logprobs
For distillation, it may be especially useful to compute top-k logprobs for each token as well, which can get you a sense for what the model "would have said" after each prefix instead of the actual prompt.

sample_response = sampling_client.sample(
    prompt=prompt,
    num_samples=1,
    sampling_params=tinker.SamplingParams(max_tokens=1),
    include_prompt_logprobs=True,
    topk_prompt_logprobs=5,
).result()
 
# example:
# [None, 
#  [(14924, -1.17005), (755, -2.23255), (2, -2.73255), (791, -3.67005), (16309, -4.29505)],
#  [(25, -1.64629), (3137, -2.39629), (11630, -2.89629), (21460, -3.83379), (14881, -4.02129)],
#  [(41, -3.49866), (42, -3.49866), (49, -4.24866), (38, -4.37366), (54, -4.49866)],
#  [(311, -1.00217), (656, -2.25217), (2057, -2.75217), (649, -3.25217), (10470, -3.37717)],
#  ...]
sample_response.topk_prompt_logprobs

Loss functions in Tinker
For most use cases, you can use the Tinker API's built-in loss functions by passing in a string identifier to forward_backward, which supports cross-entropy and policy gradient objectives. When you need more control, forward_backward_custom enables arbitrary differentiable loss functions at the cost of an additional forward pass; we explain both approaches in this doc.

When you call forward_backward, you specify a loss function using a string that selects from a predetermined set of options, comprising the most common losses used for language model training.

Input: forward_backward expects a certain set of input tensors, passed in via datum.loss_fn_inputs, which is a dict mapping str to either a numpy or torch tensor
Output: forward_backward returns a ForwardBackwardOutput, which has a set of output tensors in fwd_bwd_result.loss_fn_outputs
For an example of using forward_backward, see rl/train.py in the Cookbook:

import tinker
import torch
from tinker import TensorData
 
# Create training data with required inputs
datum = tinker.Datum(
    model_input=input_tokens,
    loss_fn_inputs={
        "target_tokens": TensorData.from_torch(torch.tensor(target_tokens)),
        "logprobs": TensorData.from_torch(torch.tensor(sampling_logprobs)),  # Reference logprobs
        "advantages": TensorData.from_torch(torch.tensor(advantages)),
    }
)
 
# Option 1: Use importance sampling REINFORCE
fwd_bwd_result = await training_client.forward_backward_async(
    [datum], loss_fn="importance_sampling"
)
 
# Option 2: Use PPO with clipping
fwd_bwd_result = await training_client.forward_backward_async(
    [datum], loss_fn="ppo"
)

Basic loss functions
Currently, the Tinker API supports cross_entropy (for supervised learning), importance_sampling (for RL), and ppo (for RL). We denote the training model as 
p
Î¸
p 
Î¸
â€‹
 , the sampling distribution as 
q
q, and advantages as 
A
A. Also, for notation simplicity we omit the query and denote the full model completion sequence of tokens as 
x
x.

All losses are applied at the token level and tensors below have shape (N,) where N is model_input.length. They can be provided as numpy.ndarray or torch.Tensor, and the return values will use the same tensor type.

Supervised learning: cross_entropy
For SL, we implement the standard cross-entropy loss (i.e., negative log-likelihood), which optimizes the policy 
p
Î¸
p 
Î¸
â€‹
  to maximize the log-probability of the tokens 
x
x:

L
(
Î¸
)
=
âˆ’
E
x
[
log
â¡
p
Î¸
(
x
)
]
L(Î¸)=âˆ’E 
x
â€‹
 [logp 
Î¸
â€‹
 (x)]
where weights is either 0 or 1, typically generated from renderers.build_supervised_example (i.e., to specify the desired assistant turns to train on).

This is implemented as:

# Apply weights and compute elementwise loss
elementwise_loss = -target_logprobs * weights
# Apply sum reduction to get the total loss
loss = elementwise_loss.sum()  # scalar

Input tensors:
target_tokens: array[(N,), int] - Target token IDs
weights: array[(N,), float] - Token-level loss weights (typically from the renderer)
Output tensors:
logprobs: array[(N,), float] - Log probabilities of predicted tokens
Output diagnostics:
loss:sum (scalar) - Sum of weighted cross-entropy losses
Policy gradient: importance_sampling
For RL, we implement a common variant of the policy gradient objective, used in practical settings where the learner policy 
p
p may differ from the sampling policy 
q
q, which is common due to, e.g., non-determinism. The issue is that if these policies differ, then the objective:

L
(
Î¸
)
=
E
x
âˆ¼
p
Î¸
[
A
(
x
)
]
L(Î¸)=E 
xâˆ¼p 
Î¸
â€‹
 
â€‹
 [A(x)]
is not computed in an unbiased why due to 
x
âˆ¼
q
xâˆ¼q (sampler) not exactly matching the desired 
x
âˆ¼
p
Î¸
xâˆ¼p 
Î¸
â€‹
  (learner). To correct the bias, we use a modified "importance sampling" objective:

L
IS
(
Î¸
)
=
E
x
âˆ¼
q
[
p
Î¸
(
x
)
q
(
x
)
A
(
x
)
]
,
L 
IS
â€‹
 (Î¸)=E 
xâˆ¼q
â€‹
 [ 
q(x)
p 
Î¸
â€‹
 (x)
â€‹
 A(x)],
which yields the correct expected reward. In the formula above:

log
â¡
p
Î¸
(
x
)
logp 
Î¸
â€‹
 (x) â€“ target_logprobs is from the learner, on the forward part of the forward_backward pass.
log
â¡
q
(
x
)
logq(x) â€“ sampling_logprobs is from the sampler, recorded during sampling as a correction term.
This is implemented as:

# Compute probability ratio
prob_ratio = torch.exp(target_logprobs - sampling_logprobs)
# Compute importance-weighted loss
loss = -(prob_ratio * advantages).sum()

Input tensors:
target_tokens: array[(N,), int] - Target token IDs (from the sampler 
q
q)
logprobs: array[(N,), float] - sampling_logprobs for the tokens
advantages: array[(N,), float] - Advantage values for RL (positive to reinforce, negative to discourage)
Output tensors:
logprobs: array[(N,), float] - target_logprobs for the tokens
Output diagnostics:
loss:sum (scalar) - Sum of importance-weighted policy gradient losses 
L
IS
L 
IS
â€‹
 
Proximal Policy Optimization: ppo
PPO (Schulman et al., 2017) addresses issues with standard policy gradient methods by introducing a clipping objective that limits policy updates within a close neighborhood of the sampling distribution. This prevents updates that are too large in policy space, especially when taking multiple gradient steps on the same rollout distribution.

The objective clips the importance ratio 
p
Î¸
(
x
)
q
(
x
)
q(x)
p 
Î¸
â€‹
 (x)
â€‹
  to prevent large policy updates, where 
p
Î¸
p 
Î¸
â€‹
  is the learner policy and 
q
q is the sampling policy. Note that the PPO clipping and loss computation is applied token-wise, computing the loss for each token independently.

The PPO clipping objective is:

L
CLIP
(
Î¸
)
=
âˆ’
E
x
âˆ¼
q
[
clip
(
p
Î¸
(
x
)
q
(
x
)
,
1
âˆ’
Ïµ
low
,
1
+
Ïµ
high
)
â‹…
A
(
x
)
]
L 
CLIP
â€‹
 (Î¸)=âˆ’E 
xâˆ¼q
â€‹
 [clip( 
q(x)
p 
Î¸
â€‹
 (x)
â€‹
 ,1âˆ’Ïµ 
low
â€‹
 ,1+Ïµ 
high
â€‹
 )â‹…A(x)]
The final PPO loss combines the clipped and unclipped objectives:

L
PPO
(
Î¸
)
=
âˆ’
E
x
âˆ¼
q
[
min
â¡
(
p
Î¸
(
x
)
q
(
x
)
â‹…
A
(
x
)
,
clip
(
p
Î¸
(
x
)
q
(
x
)
,
1
âˆ’
Ïµ
low
,
1
+
Ïµ
high
)
â‹…
A
(
x
)
)
]
L 
PPO
â€‹
 (Î¸)=âˆ’E 
xâˆ¼q
â€‹
 [min( 
q(x)
p 
Î¸
â€‹
 (x)
â€‹
 â‹…A(x),clip( 
q(x)
p 
Î¸
â€‹
 (x)
â€‹
 ,1âˆ’Ïµ 
low
â€‹
 ,1+Ïµ 
high
â€‹
 )â‹…A(x))]
where 
Ïµ
low
Ïµ 
low
â€‹
  and 
Ïµ
high
Ïµ 
high
â€‹
  are hyperparameters (currently fixed to 0.2 in Tinker).

This is implemented as:

# Compute probability ratio
prob_ratio = torch.exp(target_logprobs - sampling_logprobs)
# Apply clipping
clipped_ratio = torch.clamp(prob_ratio, clip_low_threshold, clip_high_threshold)
# Compute both objectives
unclipped_objective = prob_ratio * advantages
clipped_objective = clipped_ratio * advantages
# Take minimum (most conservative)
ppo_objective = torch.min(unclipped_objective, clipped_objective)
# PPO loss is negative of objective
loss = -ppo_objective.sum()

Currently this function has the same inputs and outputs as the importance sampling REINFORCE objective above.

Additional Notes:

The loss formulation above is quite general, since the user can organize the data generation and advantage estimation in their own code. For example, the main RL training scripts in the Tinker Cookbook use group-based rollouts with per-group advantage centering similar to GRPO (Shao et al., 2024).
The functional implementations of REINFORCE and PPO do not use an additional KL term like the original GRPO work, which has been noted to be mathematically inconsistent (Zhang et al., 2025; Tang et al., 2025). However, it is possible to include a KL regularization term as part of the reward, which is mathematically correct and we provide this option in our RL training code and examples (consider the incorporate_kl_penalty function).
Notice that for all objectives we sum the token-level losses over the sequence length unlike some other loss implementations. If you would like to explore different aggregation schemes, you can include that in the advantage tensor computation.
We currently have fixed the hyperparameters 
Ïµ
low
Ïµ 
low
â€‹
  and 
Ïµ
high
Ïµ 
high
â€‹
  to 0.2.
Flexible loss functions: forward_backward_custom
For use cases outside of the above, we've provided the more flexible (but slower) methods forward_backward_custom and forward_backward_custom_async to compute a more general class of loss functions.

Usage
Here's a simple example of a custom loss function:

def logprob_squared_loss(data: list[Datum], logprobs: list[torch.Tensor]) -> tuple[torch.Tensor, dict[str, float]]:
    loss = (logprobs ** 2).sum()
    return loss, {"logprob_squared_loss": loss.item()}

You can call this loss function with forward_backward_custom like:

loss, metrics = training_client.forward_backward_custom(data, logprob_squared_loss)

You can also define loss functions which operate on multiple sequences at a time. For example, a loss function that computes the variance across the sequences (although practically useless) can be implemented as:

def variance_loss(data: list[Datum], logprobs: list[torch.Tensor]) -> tuple[torch.Tensor, dict[str, float]]:
    flat_logprobs = torch.cat(logprobs)
    variance = torch.var(flat_logprobs)
    return variance, {"variance_loss": variance.item()}

A more practical use case would be to compute a Bradley-Terry loss on pairwise comparison data -- a classic approach in RL from human feedback, as introduced and popularized by Learning to Summarize. Similarly, we can also implement Direct Preference Optimization, which also computes a loss involving pairs of sequences; see the DPO guide for more details.

If you're using a custom loss function that you think is generally useful, please let us know, and we'll add it to the list of built-in loss functions.

We detail the async version of methods in the Async and Futures of these docs.

How forward_backward_custom works
You don't need to read the following section to use forward_backward_custom, but read on if you're curious about how it works under the hood. Tinker does NOT pickle your function or send it to the server. Instead, Tinker decomposes the gradient computation into a forward call followed by a forward_backward call on an appropriately designed weighted cross-entropy loss, which lets it compute exactly the right gradient.

Mathematically, this works as follows. First, consider the full nonlinear loss function:

loss = compute_loss_from_logprobs(compute_target_logprobs(params))

We construct a loss function that is linear in the logprobs, but has the same gradient with respect to params as the full nonlinear loss:

logprobs = compute_target_logprobs(params)
surrogate_loss = (logprobs * logprob_grads).sum()
# where logprob_grads = dLoss/dLogprobs

Here's a diagram showing what happens under the hood, on the client and server.

Client Side
Server Side
Prepare Data
List of Datum objects
â†’ training data
Call forward function
Compute Custom Loss on Model Outputs
loss = custom_fn(logprobs)
â†’ loss tensor
Backward Pass
Call loss.backward()
â†’ grad_outputs (dLoss/dLogprobs)
Initial Forward Pass
â†’ model outputs (logprobs)
Forward-Backward Pass
Linear loss: sum(outputs * grad_outputs)
â†’ final gradients on weights
Since forward_backward_custom does an extra forward pass, it requires 1.5x as many FLOPs as a single forward_backward. It'll also take up to 3x as long (wall time), due to implementation details of how forward_backward operations are scheduled.



Loss functions in Tinker
For most use cases, you can use the Tinker API's built-in loss functions by passing in a string identifier to forward_backward, which supports cross-entropy and policy gradient objectives. When you need more control, forward_backward_custom enables arbitrary differentiable loss functions at the cost of an additional forward pass; we explain both approaches in this doc.

When you call forward_backward, you specify a loss function using a string that selects from a predetermined set of options, comprising the most common losses used for language model training.

Input: forward_backward expects a certain set of input tensors, passed in via datum.loss_fn_inputs, which is a dict mapping str to either a numpy or torch tensor
Output: forward_backward returns a ForwardBackwardOutput, which has a set of output tensors in fwd_bwd_result.loss_fn_outputs
For an example of using forward_backward, see rl/train.py in the Cookbook:

import tinker
import torch
from tinker import TensorData
 
# Create training data with required inputs
datum = tinker.Datum(
    model_input=input_tokens,
    loss_fn_inputs={
        "target_tokens": TensorData.from_torch(torch.tensor(target_tokens)),
        "logprobs": TensorData.from_torch(torch.tensor(sampling_logprobs)),  # Reference logprobs
        "advantages": TensorData.from_torch(torch.tensor(advantages)),
    }
)
 
# Option 1: Use importance sampling REINFORCE
fwd_bwd_result = await training_client.forward_backward_async(
    [datum], loss_fn="importance_sampling"
)
 
# Option 2: Use PPO with clipping
fwd_bwd_result = await training_client.forward_backward_async(
    [datum], loss_fn="ppo"
)

Basic loss functions
Currently, the Tinker API supports cross_entropy (for supervised learning), importance_sampling (for RL), and ppo (for RL). We denote the training model as 
p
Î¸
p 
Î¸
â€‹
 , the sampling distribution as 
q
q, and advantages as 
A
A. Also, for notation simplicity we omit the query and denote the full model completion sequence of tokens as 
x
x.

All losses are applied at the token level and tensors below have shape (N,) where N is model_input.length. They can be provided as numpy.ndarray or torch.Tensor, and the return values will use the same tensor type.

Supervised learning: cross_entropy
For SL, we implement the standard cross-entropy loss (i.e., negative log-likelihood), which optimizes the policy 
p
Î¸
p 
Î¸
â€‹
  to maximize the log-probability of the tokens 
x
x:

L
(
Î¸
)
=
âˆ’
E
x
[
log
â¡
p
Î¸
(
x
)
]
L(Î¸)=âˆ’E 
x
â€‹
 [logp 
Î¸
â€‹
 (x)]
where weights is either 0 or 1, typically generated from renderers.build_supervised_example (i.e., to specify the desired assistant turns to train on).

This is implemented as:

# Apply weights and compute elementwise loss
elementwise_loss = -target_logprobs * weights
# Apply sum reduction to get the total loss
loss = elementwise_loss.sum()  # scalar

Input tensors:
target_tokens: array[(N,), int] - Target token IDs
weights: array[(N,), float] - Token-level loss weights (typically from the renderer)
Output tensors:
logprobs: array[(N,), float] - Log probabilities of predicted tokens
Output diagnostics:
loss:sum (scalar) - Sum of weighted cross-entropy losses
Policy gradient: importance_sampling
For RL, we implement a common variant of the policy gradient objective, used in practical settings where the learner policy 
p
p may differ from the sampling policy 
q
q, which is common due to, e.g., non-determinism. The issue is that if these policies differ, then the objective:

L
(
Î¸
)
=
E
x
âˆ¼
p
Î¸
[
A
(
x
)
]
L(Î¸)=E 
xâˆ¼p 
Î¸
â€‹
 
â€‹
 [A(x)]
is not computed in an unbiased why due to 
x
âˆ¼
q
xâˆ¼q (sampler) not exactly matching the desired 
x
âˆ¼
p
Î¸
xâˆ¼p 
Î¸
â€‹
  (learner). To correct the bias, we use a modified "importance sampling" objective:

L
IS
(
Î¸
)
=
E
x
âˆ¼
q
[
p
Î¸
(
x
)
q
(
x
)
A
(
x
)
]
,
L 
IS
â€‹
 (Î¸)=E 
xâˆ¼q
â€‹
 [ 
q(x)
p 
Î¸
â€‹
 (x)
â€‹
 A(x)],
which yields the correct expected reward. In the formula above:

log
â¡
p
Î¸
(
x
)
logp 
Î¸
â€‹
 (x) â€“ target_logprobs is from the learner, on the forward part of the forward_backward pass.
log
â¡
q
(
x
)
logq(x) â€“ sampling_logprobs is from the sampler, recorded during sampling as a correction term.
This is implemented as:

# Compute probability ratio
prob_ratio = torch.exp(target_logprobs - sampling_logprobs)
# Compute importance-weighted loss
loss = -(prob_ratio * advantages).sum()

Input tensors:
target_tokens: array[(N,), int] - Target token IDs (from the sampler 
q
q)
logprobs: array[(N,), float] - sampling_logprobs for the tokens
advantages: array[(N,), float] - Advantage values for RL (positive to reinforce, negative to discourage)
Output tensors:
logprobs: array[(N,), float] - target_logprobs for the tokens
Output diagnostics:
loss:sum (scalar) - Sum of importance-weighted policy gradient losses 
L
IS
L 
IS
â€‹
 
Proximal Policy Optimization: ppo
PPO (Schulman et al., 2017) addresses issues with standard policy gradient methods by introducing a clipping objective that limits policy updates within a close neighborhood of the sampling distribution. This prevents updates that are too large in policy space, especially when taking multiple gradient steps on the same rollout distribution.

The objective clips the importance ratio 
p
Î¸
(
x
)
q
(
x
)
q(x)
p 
Î¸
â€‹
 (x)
â€‹
  to prevent large policy updates, where 
p
Î¸
p 
Î¸
â€‹
  is the learner policy and 
q
q is the sampling policy. Note that the PPO clipping and loss computation is applied token-wise, computing the loss for each token independently.

The PPO clipping objective is:

L
CLIP
(
Î¸
)
=
âˆ’
E
x
âˆ¼
q
[
clip
(
p
Î¸
(
x
)
q
(
x
)
,
1
âˆ’
Ïµ
low
,
1
+
Ïµ
high
)
â‹…
A
(
x
)
]
L 
CLIP
â€‹
 (Î¸)=âˆ’E 
xâˆ¼q
â€‹
 [clip( 
q(x)
p 
Î¸
â€‹
 (x)
â€‹
 ,1âˆ’Ïµ 
low
â€‹
 ,1+Ïµ 
high
â€‹
 )â‹…A(x)]
The final PPO loss combines the clipped and unclipped objectives:

L
PPO
(
Î¸
)
=
âˆ’
E
x
âˆ¼
q
[
min
â¡
(
p
Î¸
(
x
)
q
(
x
)
â‹…
A
(
x
)
,
clip
(
p
Î¸
(
x
)
q
(
x
)
,
1
âˆ’
Ïµ
low
,
1
+
Ïµ
high
)
â‹…
A
(
x
)
)
]
L 
PPO
â€‹
 (Î¸)=âˆ’E 
xâˆ¼q
â€‹
 [min( 
q(x)
p 
Î¸
â€‹
 (x)
â€‹
 â‹…A(x),clip( 
q(x)
p 
Î¸
â€‹
 (x)
â€‹
 ,1âˆ’Ïµ 
low
â€‹
 ,1+Ïµ 
high
â€‹
 )â‹…A(x))]
where 
Ïµ
low
Ïµ 
low
â€‹
  and 
Ïµ
high
Ïµ 
high
â€‹
  are hyperparameters (currently fixed to 0.2 in Tinker).

This is implemented as:

# Compute probability ratio
prob_ratio = torch.exp(target_logprobs - sampling_logprobs)
# Apply clipping
clipped_ratio = torch.clamp(prob_ratio, clip_low_threshold, clip_high_threshold)
# Compute both objectives
unclipped_objective = prob_ratio * advantages
clipped_objective = clipped_ratio * advantages
# Take minimum (most conservative)
ppo_objective = torch.min(unclipped_objective, clipped_objective)
# PPO loss is negative of objective
loss = -ppo_objective.sum()

Currently this function has the same inputs and outputs as the importance sampling REINFORCE objective above.

Additional Notes:

The loss formulation above is quite general, since the user can organize the data generation and advantage estimation in their own code. For example, the main RL training scripts in the Tinker Cookbook use group-based rollouts with per-group advantage centering similar to GRPO (Shao et al., 2024).
The functional implementations of REINFORCE and PPO do not use an additional KL term like the original GRPO work, which has been noted to be mathematically inconsistent (Zhang et al., 2025; Tang et al., 2025). However, it is possible to include a KL regularization term as part of the reward, which is mathematically correct and we provide this option in our RL training code and examples (consider the incorporate_kl_penalty function).
Notice that for all objectives we sum the token-level losses over the sequence length unlike some other loss implementations. If you would like to explore different aggregation schemes, you can include that in the advantage tensor computation.
We currently have fixed the hyperparameters 
Ïµ
low
Ïµ 
low
â€‹
  and 
Ïµ
high
Ïµ 
high
â€‹
  to 0.2.
Flexible loss functions: forward_backward_custom
For use cases outside of the above, we've provided the more flexible (but slower) methods forward_backward_custom and forward_backward_custom_async to compute a more general class of loss functions.

Usage
Here's a simple example of a custom loss function:

def logprob_squared_loss(data: list[Datum], logprobs: list[torch.Tensor]) -> tuple[torch.Tensor, dict[str, float]]:
    loss = (logprobs ** 2).sum()
    return loss, {"logprob_squared_loss": loss.item()}

You can call this loss function with forward_backward_custom like:

loss, metrics = training_client.forward_backward_custom(data, logprob_squared_loss)

You can also define loss functions which operate on multiple sequences at a time. For example, a loss function that computes the variance across the sequences (although practically useless) can be implemented as:

def variance_loss(data: list[Datum], logprobs: list[torch.Tensor]) -> tuple[torch.Tensor, dict[str, float]]:
    flat_logprobs = torch.cat(logprobs)
    variance = torch.var(flat_logprobs)
    return variance, {"variance_loss": variance.item()}

A more practical use case would be to compute a Bradley-Terry loss on pairwise comparison data -- a classic approach in RL from human feedback, as introduced and popularized by Learning to Summarize. Similarly, we can also implement Direct Preference Optimization, which also computes a loss involving pairs of sequences; see the DPO guide for more details.

If you're using a custom loss function that you think is generally useful, please let us know, and we'll add it to the list of built-in loss functions.

We detail the async version of methods in the Async and Futures of these docs.

How forward_backward_custom works
You don't need to read the following section to use forward_backward_custom, but read on if you're curious about how it works under the hood. Tinker does NOT pickle your function or send it to the server. Instead, Tinker decomposes the gradient computation into a forward call followed by a forward_backward call on an appropriately designed weighted cross-entropy loss, which lets it compute exactly the right gradient.

Mathematically, this works as follows. First, consider the full nonlinear loss function:

loss = compute_loss_from_logprobs(compute_target_logprobs(params))

We construct a loss function that is linear in the logprobs, but has the same gradient with respect to params as the full nonlinear loss:

logprobs = compute_target_logprobs(params)
surrogate_loss = (logprobs * logprob_grads).sum()
# where logprob_grads = dLoss/dLogprobs

Here's a diagram showing what happens under the hood, on the client and server.

Client Side
Server Side
Prepare Data
List of Datum objects
â†’ training data
Call forward function
Compute Custom Loss on Model Outputs
loss = custom_fn(logprobs)
â†’ loss tensor
Backward Pass
Call loss.backward()
â†’ grad_outputs (dLoss/dLogprobs)
Initial Forward Pass
â†’ model outputs (logprobs)
Forward-Backward Pass
Linear loss: sum(outputs * grad_outputs)
â†’ final gradients on weights
Since forward_backward_custom does an extra forward pass, it requires 1.5x as many FLOPs as a single forward_backward. It'll also take up to 3x as long (wall time), due to implementation details of how forward_backward operations are scheduled.

Last updated on November 20, 2025
Training and Sampling
Saving and Loading
Tinker API Documentation

Saving and loading weights and optimizer state
During training, you'll need to save checkpoints for two main purposes: sampling (to test your model) and resuming training (to continue from where you left off). The TrainingClient provides three methods to handle these cases:

save_weights_for_sampler(): saves a copy of the model weights that can be used for sampling.
save_state(): saves the weights and the optimizer state. You can fully resume training from this checkpoint.
load_state(): load the weights and the optimizer state. You can fully resume training from this checkpoint.
Note that (1) is faster and requires less storage space than (2).

Both save_* functions require a name parameter---a string that you can set to identify the checkpoint within the current training run. For example, you can name your checkpoints "0000", "0001", "step_1000", etc.

The return value contains a path field, which is a fully-qualified path, which will look something like tinker://<model_id>/<name>. This path is persistent and can be loaded later by a new ServiceClient or TrainingClient.

Example: Saving for sampling
# Setup
import tinker
service_client = tinker.ServiceClient()
training_client = service_client.create_lora_training_client(
    base_model="meta-llama/Llama-3.2-1B", rank=32
)
 
# Save a checkpoint that you can use for sampling
sampling_path = training_client.save_weights_for_sampler(name="0000").result().path
 
# Create a sampling client with that checkpoint
sampling_client = service_client.create_sampling_client(model_path=sampling_path) #

Shortcut: Combine these steps with:

sampling_client = training_client.save_weights_and_get_sampling_client(name="0000")

Example: Saving to resume training
Use save_state() and load_state() when you need to pause and continue training with full optimizer state preserved:

# Save a checkpoint that you can resume from
resume_path = training_client.save_state(name="0010").result().path
 
# Load that checkpoint
training_client.load_state(resume_path)

When to use save_state() and load_state():
Multi-step training pipelines (e.g. supervised learning followed by reinforcement learning)
Adjusting hyperparameters or data mid-run
Recovery from interruptions or failures
Any scenario where you need to preserve exact optimizer state (momentum, learning rate schedules, etc.)
Last updated on November 20, 2025
Loss Functions
Downloading Weights
Tinker API Documentation

Downloading weights
CLI
tinker checkpoint download $TINKER_CHECKPOINT_PATH

See tinker checkpoint download --help for more details.

SDK
You can also download checkpoints using the SDK.

Example:

import tinker
import urllib.request
 
sc = tinker.ServiceClient()
rc = sc.create_rest_client()
future = rc.get_checkpoint_archive_url_from_tinker_path("tinker://<unique_id>/sampler_weights/final")
checkpoint_archive_url_response = future.result()
 
# `checkpoint_archive_url_response.url` is a signed URL that can be downloaded
# until checkpoint_archive_url_response.expires
urllib.request.urlretrieve(checkpoint_archive_url_response.url, "archive.tar")

Replace <unique_id> with your Training Run ID. This will save the LoRA adapter weights and config inside the archive.tar file.

Last updated on November 20, 2025
Saving and Loading
Publishing Weights
Tinker API Documentation

Publishing weights
If you've trained a model that you'd like to share with the community, you can publish any number of checkpoints you've previously saved.

Once published, your checkpoint can be loaded by any tinker user and used to further train a new model or be sampled against.

Publishing
tinker checkpoint publish $TINKER_CHECKPOINT_PATH

where $TINKER_CHECKPOINT_PATH is a checkpoint path in the form of tinker://14bdf3a1-0b95-55c7-8659-5edb1bc870af:train:17/weights/checkpoint_id_to_publish.

You may confirm your checkpoint is published by dumping the checkpoint info and checking the Public property:

tinker checkpoint info tinker://14bdf3a1-0b95-55c7-8659-5edb1bc870af/weights/checkpoint_id_to_publish
                              Checkpoint: weights/checkpoint_id_to_publish
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”³â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ Property        â”ƒ Value                                                                          â”ƒ
â”¡â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•‡â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”©
â”‚ Checkpoint ID   â”‚ weights/checkpoint_id_to_publish                                               â”‚
â”‚ Type            â”‚ training                                                                       â”‚
â”‚ Tinker Path     â”‚ tinker://14bdf3a1-0b95-55c7-8659-5edb1bc870af/weights/checkpoint_id_to_publish â”‚
â”‚ Size            â”‚ 342.4 MB                                                                       â”‚
â”‚ Public          â”‚ No                                                                             â”‚
â”‚ Created         â”‚ 23 minutes ago                                                                 â”‚
â”‚ Training Run ID â”‚ 14bdf3a1-0b95-55c7-8659-5edb1bc870af                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Unpublishing
tinker checkpoint unpublish $TINKER_CHECKPOINT_PATH`

Loading public weights
Loading public weights is slightly different from loading your own weights. Rather than using:

ckpt_path = ...
training_client = service_client.create_training_client_from_state(ckpt_path)

you must do the following because training run metadata remains private to the owner:

ckpt_path = ...
base_model = ...
rank = ...
 
training_client = service_client.create_lora_training_client(base_model, rank)
training_client.load_state(cpkt_path).result()

Last updated on November 20, 2025
Downloading Weights
Async and Futures
Tinker API Documentation

Publishing weights
If you've trained a model that you'd like to share with the community, you can publish any number of checkpoints you've previously saved.

Once published, your checkpoint can be loaded by any tinker user and used to further train a new model or be sampled against.

Publishing
tinker checkpoint publish $TINKER_CHECKPOINT_PATH

where $TINKER_CHECKPOINT_PATH is a checkpoint path in the form of tinker://14bdf3a1-0b95-55c7-8659-5edb1bc870af:train:17/weights/checkpoint_id_to_publish.

You may confirm your checkpoint is published by dumping the checkpoint info and checking the Public property:

tinker checkpoint info tinker://14bdf3a1-0b95-55c7-8659-5edb1bc870af/weights/checkpoint_id_to_publish
                              Checkpoint: weights/checkpoint_id_to_publish
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”³â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ Property        â”ƒ Value                                                                          â”ƒ
â”¡â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•‡â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”©
â”‚ Checkpoint ID   â”‚ weights/checkpoint_id_to_publish                                               â”‚
â”‚ Type            â”‚ training                                                                       â”‚
â”‚ Tinker Path     â”‚ tinker://14bdf3a1-0b95-55c7-8659-5edb1bc870af/weights/checkpoint_id_to_publish â”‚
â”‚ Size            â”‚ 342.4 MB                                                                       â”‚
â”‚ Public          â”‚ No                                                                             â”‚
â”‚ Created         â”‚ 23 minutes ago                                                                 â”‚
â”‚ Training Run ID â”‚ 14bdf3a1-0b95-55c7-8659-5edb1bc870af                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Unpublishing
tinker checkpoint unpublish $TINKER_CHECKPOINT_PATH`

Loading public weights
Loading public weights is slightly different from loading your own weights. Rather than using:

ckpt_path = ...
training_client = service_client.create_training_client_from_state(ckpt_path)

you must do the following because training run metadata remains private to the owner:

ckpt_path = ...
base_model = ...
rank = ...
 
training_client = service_client.create_lora_training_client(base_model, rank)
training_client.load_state(cpkt_path).result()

Last updated on November 20, 2025
Downloading Weights
Async and Futures
Tinker API Documentation

Available Models in Tinker
The table below shows the models that are currently available in Tinker. We plan to update this list as new models are released.

What model should I use?
In general, use MoE models, which are more cost effective than the dense models.
Use ğŸ™ Base models only if you're doing research or are running the full post-training pipeline yourself
If you want to create a model that is good at a specific task or domain, use an existing post-trained model model, and fine-tune it on your own data or environment.
If you care about latency, use one of the "âš¡ Instruction" models, which will start outputting tokens without a chain-of-thought.
If you care about intelligence and robustness, use one of the "ğŸ¤” Hybrid" or "ğŸ’­ Reasoning" models, which can use long chain-of-thought.
Full Listing
Model Name	Training Type	Architecture	Size
Qwen/Qwen3-235B-A22B-Instruct-2507	âš¡ Instruction	ğŸ”€ MoE	ğŸ¦– Large
Qwen/Qwen3-30B-A3B-Instruct-2507	âš¡ Instruction	ğŸ”€ MoE	ğŸ¦… Medium
Qwen/Qwen3-30B-A3B	ğŸ¤” Hybrid	ğŸ”€ MoE	ğŸ¦… Medium
Qwen/Qwen3-30B-A3B-Base	ğŸ™ Base	ğŸ”€ MoE	ğŸ¦… Medium
Qwen/Qwen3-32B	ğŸ¤” Hybrid	ğŸ§± Dense	ğŸ¦… Medium
Qwen/Qwen3-8B	ğŸ¤” Hybrid	ğŸ§± Dense	ğŸ¦† Small
Qwen/Qwen3-8B-Base	ğŸ™ Base	ğŸ§± Dense	ğŸ¦† Small
Qwen/Qwen3-4B-Instruct-2507	âš¡ Instruction	ğŸ§± Dense	ğŸ£ Compact
openai/gpt-oss-120b	ğŸ’­ Reasoning	ğŸ”€ MoE	ğŸ¦… Medium
openai/gpt-oss-20b	ğŸ’­ Reasoning	ğŸ”€ MoE	ğŸ¦† Small
deepseek-ai/DeepSeek-V3.1	ğŸ¤” Hybrid	ğŸ”€ MoE	ğŸ¦– Large
deepseek-ai/DeepSeek-V3.1-Base	ğŸ™ Base	ğŸ”€ MoE	ğŸ¦– Large
meta-llama/Llama-3.1-70B	ğŸ™ Base	ğŸ§± Dense	ğŸ¦– Large
meta-llama/Llama-3.3-70B-Instruct	âš¡ Instruction	ğŸ§± Dense	ğŸ¦– Large
meta-llama/Llama-3.1-8B	ğŸ™ Base	ğŸ§± Dense	ğŸ¦† Small
meta-llama/Llama-3.1-8B-Instruct	âš¡ Instruction	ğŸ§± Dense	ğŸ¦† Small
meta-llama/Llama-3.2-3B	ğŸ™ Base	ğŸ§± Dense	ğŸ£ Compact
meta-llama/Llama-3.2-1B	ğŸ™ Base	ğŸ§± Dense	ğŸ£ Compact
Legend
Training Types
ğŸ™ Base: Foundation models trained on raw text data, suitable for post-training research and custom fine-tuning.
âš¡ Instruction: Models fine-tuned for following instructions and chat, optimized for fast inference.
ğŸ’­ Reasoning: Models that always use chain-of-thought reasoning before their "visible" output that responds to the prompt.
ğŸ¤” Hybrid: Models that can operate in both thinking and non-thinking modes, where the non-thinking mode requires using a special renderer or argument that disables chain-of-thought.
Architecture
ğŸ§± Dense: Standard transformer architecture with all parameters active
ğŸ”€ MoE: Mixture of Experts architecture with sparse activation
Model Sizes
ğŸ£ Compact: 1B-4B parameters
ğŸ¦† Small: 8B parameters
ğŸ¦… Medium: 30B-32B parameters
ğŸ¦– Large: 70B+ parameters
Note that the MoE models are much more cost effective than the dense models as their cost is proportional to the number of active parameters and not the total number of parameters.

Last updated on November 20, 2025
Async and Futures
Rendering
Tinker API Documentation

Available Models in Tinker
The table below shows the models that are currently available in Tinker. We plan to update this list as new models are released.

What model should I use?
In general, use MoE models, which are more cost effective than the dense models.
Use ğŸ™ Base models only if you're doing research or are running the full post-training pipeline yourself
If you want to create a model that is good at a specific task or domain, use an existing post-trained model model, and fine-tune it on your own data or environment.
If you care about latency, use one of the "âš¡ Instruction" models, which will start outputting tokens without a chain-of-thought.
If you care about intelligence and robustness, use one of the "ğŸ¤” Hybrid" or "ğŸ’­ Reasoning" models, which can use long chain-of-thought.
Full Listing
Model Name	Training Type	Architecture	Size
Qwen/Qwen3-235B-A22B-Instruct-2507	âš¡ Instruction	ğŸ”€ MoE	ğŸ¦– Large
Qwen/Qwen3-30B-A3B-Instruct-2507	âš¡ Instruction	ğŸ”€ MoE	ğŸ¦… Medium
Qwen/Qwen3-30B-A3B	ğŸ¤” Hybrid	ğŸ”€ MoE	ğŸ¦… Medium
Qwen/Qwen3-30B-A3B-Base	ğŸ™ Base	ğŸ”€ MoE	ğŸ¦… Medium
Qwen/Qwen3-32B	ğŸ¤” Hybrid	ğŸ§± Dense	ğŸ¦… Medium
Qwen/Qwen3-8B	ğŸ¤” Hybrid	ğŸ§± Dense	ğŸ¦† Small
Qwen/Qwen3-8B-Base	ğŸ™ Base	ğŸ§± Dense	ğŸ¦† Small
Qwen/Qwen3-4B-Instruct-2507	âš¡ Instruction	ğŸ§± Dense	ğŸ£ Compact
openai/gpt-oss-120b	ğŸ’­ Reasoning	ğŸ”€ MoE	ğŸ¦… Medium
openai/gpt-oss-20b	ğŸ’­ Reasoning	ğŸ”€ MoE	ğŸ¦† Small
deepseek-ai/DeepSeek-V3.1	ğŸ¤” Hybrid	ğŸ”€ MoE	ğŸ¦– Large
deepseek-ai/DeepSeek-V3.1-Base	ğŸ™ Base	ğŸ”€ MoE	ğŸ¦– Large
meta-llama/Llama-3.1-70B	ğŸ™ Base	ğŸ§± Dense	ğŸ¦– Large
meta-llama/Llama-3.3-70B-Instruct	âš¡ Instruction	ğŸ§± Dense	ğŸ¦– Large
meta-llama/Llama-3.1-8B	ğŸ™ Base	ğŸ§± Dense	ğŸ¦† Small
meta-llama/Llama-3.1-8B-Instruct	âš¡ Instruction	ğŸ§± Dense	ğŸ¦† Small
meta-llama/Llama-3.2-3B	ğŸ™ Base	ğŸ§± Dense	ğŸ£ Compact
meta-llama/Llama-3.2-1B	ğŸ™ Base	ğŸ§± Dense	ğŸ£ Compact
Legend
Training Types
ğŸ™ Base: Foundation models trained on raw text data, suitable for post-training research and custom fine-tuning.
âš¡ Instruction: Models fine-tuned for following instructions and chat, optimized for fast inference.
ğŸ’­ Reasoning: Models that always use chain-of-thought reasoning before their "visible" output that responds to the prompt.
ğŸ¤” Hybrid: Models that can operate in both thinking and non-thinking modes, where the non-thinking mode requires using a special renderer or argument that disables chain-of-thought.
Architecture
ğŸ§± Dense: Standard transformer architecture with all parameters active
ğŸ”€ MoE: Mixture of Experts architecture with sparse activation
Model Sizes
ğŸ£ Compact: 1B-4B parameters
ğŸ¦† Small: 8B parameters
ğŸ¦… Medium: 30B-32B parameters
ğŸ¦– Large: 70B+ parameters
Note that the MoE models are much more cost effective than the dense models as their cost is proportional to the number of active parameters and not the total number of parameters.

Last updated on November 20, 2025
Async and Futures
Rendering
Tinker API Documentation

LoRA Primer
Tinker supports LoRA fine-tuning, which adjusts a small number of parameters, rather than full fine-tuning, which adjusts all of the parameters of the original model.

Our current understanding is that LoRA has equivalent performance to full fine-tuning when doing RL or doing SL on small datasets, while it has worse performance on larger datasets. In more detail:

For supervised fine-tuning on small-to-medium-sized instruction-tuning and reasoning datasets, LoRA performs the same as full fine-tuning.
For datasets that exceed LoRA capacity, LoRA underperforms FullFT. Rather than the loss reaching a distinct floor that it canâ€™t go below, LoRA results in worse training efficiency that depends on the relationship between model capacity to dataset size.
In some scenarios, LoRA is less tolerant of large batch sizes than full fine-tuning â€” it pays a larger penalty in loss as batch size increases beyond some point. This penalty is not mitigated by increasing the LoRA rank; it is a property of the product-of-matrices parametrization, which has different training dynamics than optimizing the original weight matrix.
Even in small data settings, LoRA performs better when applied to all weight matrices, especially MLP and MoE layers. Attention-only LoRA underperforms even when we match the number of trainable parameters by using higher rank for attention-only LoRA.
LoRA performs equivalently to FullFT for reinforcement learning even with small ranks. We find that RL requires very low capacity, a result we anticipated based on information-theoretical arguments.
See LoRA Without Regret for more details and experimental results.

Hyperparameters
The learning rate (LR) is usually the most important hyperparameter in your ML experiments.

LoRA requires a much larger LR than full fine-tuning---typically 20-100x larger, depending on model size. People often mistakenly retain their full fine-tuning LR when they port their code to use LoRA, leading them to conclude that LoRA works poorly.

Calculate the correct LoRA learning rate:

We've provided a utility that calculates the factor you should scale the full fine-tuning LR by to get the equivalent LoRA LR:

from tinker_cookbook.hyperparam_utils import get_lora_lr_over_full_finetune_lr
 
model_name = "meta-llama/Llama-3.1-8B"
print(get_lora_lr_over_full_finetune_lr(model_name))

Note that for Llama-3.2-1B, the factor is 32, while for Llama-3.1-70B, the factor is 128.

What is LoRA exactly?
LoRA is short for Low-Rank Adaptation. Given that the original model has a weight matrix 
W
W, we replace it with a new weight matrix 
W
â€²
=
W
+
B
A
W 
â€²
 =W+BA, where 
B
B and 
A
A are low-rank matrices. If 
W
W is an 
n
Ã—
n
nÃ—n matrix, then 
B
B and 
A
A are 
n
Ã—
r
nÃ—r and 
r
Ã—
n
rÃ—n matrices, respectively, where 
r
r is the rank of the low-rank approximation. The default 
r
r used by tinker is 
32
32.

The fact that LoRA uses a low-rank approximation of weight matrices is not terribly important. We prefer to think of LoRA as just a random projection of the parameter space that happens to be efficient to implement. When training with RL or small SL datasets, we are only learning a small amount of information, and this reduced set of parameters is more than enough.

What rank to use?
The default rank used by tinker is 
32
32. However, if you're doing SL on a large dataset, you should use a larger rank. For supervised learning, as a very rough approximation, LoRA will give good results as long as the number of LoRA parameters is at least as large as the number of completion tokens (i.e., weight=1 tokens). You can calculate the number of LoRA parameters with the following utility:

from tinker_cookbook.hyperparam_utils import get_lora_param_count
 
model_name = "meta-llama/Llama-3.1-8B"
print(get_lora_param_count(model_name, lora_rank=32))

For reinforcement learning, we've found that small ranks give equivalent performance to larger ranks and full fine-tuning.

Note that conveniently, the optimal learning rate does not depend on the LoRA rank. In fact, you can verify that if you train with SL on different ranks (but with the same LR), you'll get exactly the same learning curves for the first few steps of training.

Last updated on November 20, 2025
Rendering
Supervised Learning
Tinker API Documentation

Basic Supervised Learning
This guide walks you through running your first supervised learning experiment using Tinker's built-in training loop.

Quick start
We've provided an implementation of supervised learning in train_cli.py. To use this training loop, you'll need to create a Config object with the data and parameters.

We've provided a ready-to-run example that fine-tunes Llama-3.1-8B on a small instruction-following dataset in sl_basic.py. You can run it from the command line as follows:

python -m tinker_cookbook.recipes.sl_basic

This script fine-tunes the base (pretrained) model on a small dataset called NoRobots, created by Hugging Face.

What you'll see during training
Each step you should see a printout of the train and test loss, along with other stats like timing.
The training script will also print out what the data looks like, with predicted tokens (weight=1) in green and context tokens (weight=0) in yellow.
The training script will write various logs and checkpoint info to the log_path directory, which is set to /tmp/tinker-examples/sl_basic in the example script.
Understanding the output files
Looking at the log_path directory, you will find several files of interest:

metrics.jsonl: the training metrics that also were printed to the console. You can load and plot them like this:

import pandas
import matplotlib.pyplot as plt
df = pandas.read_json("/tmp/tinker-examples/sl_basic/metrics.jsonl", lines=True)
plt.plot(df['train_mean_nll'], label='train_loss')
plt.plot(df['test/nll'].dropna(), label='test_loss')
plt.legend()
plt.show()

You should see a plot like this:Train and test loss as a function of steps

checkpoints.jsonl: the checkpoints that were saved during training. Recall from Saving and Loading that there are (currently) two kinds of checkpoints: one that has "/sampler_weights/" in the path (used for sampling), and the other that has "/weights/" in the path (includes full optimizer state, used for resuming training). If you interrupt the training script, then run it again, it will ask you if you want to resume training. If you choose to do so, it'll load the last (full state) checkpoint from this file.
config.json: the configuration that you used for training.
In the sl_basic script, you'll see that there's also some disabled code (under if 0:) that shows how to use your own dataset, specified as a JSONL file, provided in the format of conversations.jsonl.

Last updated on November 20, 2025
Supervised Learning
SL training loop
Tinker API Documentation

Supervised Learning Training Loop
We've provided a simple SL training loop in sl_loop.py, which avoids using our dataset classes and instead defines the data loading in a more self-contained way. This is for people who like to write their own training loops or learn about how things work under the hood. Our more performant implementation in supervised/train.py does basically the same thing, but with some performance optimizations, and with some additional features like periodic evals.

Last updated on November 20, 2025
Basic SL
SL hyperparams
Tinker API Documentation

Supervised Learning Hyperparameters
Successful LLM fine-tuning requires careful hyperparameter tuning. While the most accurate approach is to sweep over ranges and selecting values that minimize loss or maximize eval performance for each hyperparameter, this is often time-consuming and expensive. This guide provides some starting recommendations for the most important hyperparameters.

Learning rate
The most important hyperparameter is generally the learning rate (LR). Our current best estimate of optimal LR for a model 
m
m is the following:

L
R
(
m
)
=
l
r
b
a
s
e
â‹…
M
L
o
R
A
â‹…
(
2000
H
m
)
P
m
LR(m)=lr 
base
â€‹
 â‹…M 
LoRA
â€‹
 â‹…( 
H 
m
â€‹
 
2000
â€‹
 ) 
P 
m
â€‹
 
 

where 
l
r
b
a
s
e
lr 
base
â€‹
  is a constant base LR, 
M
L
o
R
A
M 
LoRA
â€‹
  is a multiplier applied when using LoRA (1 if using full-finetuning), 
H
m
H 
m
â€‹
  is the hidden size of the model 
m
m, and 
P
m
P 
m
â€‹
  is a model-specific exponent adjustment. Importantly, this function is independent of the LoRA rank.

Our current best estimates are the following: 
l
r
b
a
s
e
=
5
e
âˆ’
5
lr 
base
â€‹
 =5eâˆ’5, 
M
L
o
R
A
=
10
M 
LoRA
â€‹
 =10, 
P
m
=
0.0775
P 
m
â€‹
 =0.0775 for Qwen models and 
P
m
=
0.781
P 
m
â€‹
 =0.781 for Llama models.

Getting the recommended learning rate
You can use the following function to get the recommended LR for any model:

from tinker_cookbook.hyperparam_utils import get_lr
model_name = "meta-llama/Llama-3.2-1B"
recommended_lr = get_lr(model_name)
print(f"Recommended LR: {recommended_lr}")

Validation
We validated this formula across diverse supervised fine-tuning experiments, varying datasets, dataset sizes, batch_sizes and lora_ranks.

Using our LR estimates resulted in <0.5% regret compared to exhaustive hyperparameter sweeps, where regret is defined as:

We can define the regret of using any lr as the following: 
r
e
g
r
e
t
(
l
r
â€²
)
=
l
o
s
s
(
l
r
â€²
)
âˆ’
m
i
n
l
r
l
o
s
s
(
l
r
)
m
i
n
l
r
l
o
s
s
(
l
r
)
regret(lr 
â€²
 )= 
min 
lr
â€‹
 loss(lr)
loss(lr 
â€²
 )âˆ’min 
lr
â€‹
 loss(lr)
â€‹
 

Batch size
Batch size is the second-most important hyperparameter; it significantly affects both training efficiency and final performance.

For small batch sizes, there's a phenomenon of perfect scaling, where the LR and batchsize should be varied together as 
L
R
âˆ
B
LRâˆ 
B
â€‹
 , and the learning curve only depends on 
L
R
B
B
â€‹
 
LR
â€‹
 . See Shallue et al. (2018) for an example in the training-from-scratch setting.

When fine-tuning LLMs, we're often in a regime where smaller batch sizes give better performance, at the cost of longer training time; moreover, the 
L
R
âˆ
B
LRâˆ 
B
â€‹
  scaling doesn't always hold. When doing SL fine-tuning, we recommend using smaller batch sizes like 128, depending on your tolerance for longer training time.

For best results, you should aim for at least 100 steps of training (but usually get best results with 1000 or more).

âš ï¸ Note: Our batch size recommendations are based on preliminary findings and ongoing research. We're not confident about them!

Last updated on November 20, 2025
SL training loop
Prompt distillation
Tinker API Documentation

Prompt Distillation
Prompt distillation is a training technique in which a model is optimized to behave as though it had been provided with a long and complex prompt, without requiring access to that prompt during inference.

At a high level, this procedure involves two main steps:

Creation of distillation data: A teacher prompt, which is typically lengthy and highly detailed, provides explicit, step-by-step instructions. A teacher model uses this prompt to generate responses for a set of queries.
Training the student model: A student model is then trained (or fine-tuned) on the distilled dataset, thereby learning to reproduce the essential behaviors and reasoning encoded in the teacherâ€™s instructions.
Overview
Let 
f
T
f 
T
â€‹
  and 
f
S
f 
S
â€‹
  denote the teacher and student models, respectively. Given an instruction prompt 
P
P and a query 
q
i
q 
i
â€‹
 , the teacher model generates a response 
r
i
r 
i
â€‹
 :

r
i
=
f
T
(
[
P
,
q
i
]
)
r 
i
â€‹
 =f 
T
â€‹
 ([P,q 
i
â€‹
 ])
Here, the prompt 
P
P and the query 
q
i
q 
i
â€‹
  are concatenated to form the input to the teacher model 
f
T
f 
T
â€‹
 . For a dataset of queries 
Q
=
{
q
i
âˆ£
1
â‰¤
i
â‰¤
D
}
Q={q 
i
â€‹
 âˆ£1â‰¤iâ‰¤D}, we obtain a corresponding set of teacher responses 
R
=
{
r
i
âˆ£
1
â‰¤
i
â‰¤
D
}
R={r 
i
â€‹
 âˆ£1â‰¤iâ‰¤D}.

The distillation training dataset is defined as the set of queryâ€“response pairs (excluding the original prompt):

T
=
{
(
q
i
,
r
i
)
âˆ£
1
â‰¤
i
â‰¤
D
}
.
T={(q 
i
â€‹
 ,r 
i
â€‹
 )âˆ£1â‰¤iâ‰¤D}.
The student model 
f
S
f 
S
â€‹
  is then trained to minimize the cross-entropy loss:

â„“
(
f
S
(
q
i
)
,
r
i
)
=
â„“
(
f
S
(
q
i
)
,
f
T
(
[
P
,
q
i
]
)
)
.
â„“(f 
S
â€‹
 (q 
i
â€‹
 ),r 
i
â€‹
 )=â„“(f 
S
â€‹
 (q 
i
â€‹
 ),f 
T
â€‹
 ([P,q 
i
â€‹
 ])).
Example
The Tinker Cookbook provides a prompt distillation recipe tailored for a language classification task. The objective is straightforward: given a text query, the model should predict a two-character code corresponding to the language of the input. The set of possible labels is:

ar (Arabic), de (German), el (Greek), en (English), es (Spanish), fr (French), hi (Hindi), ru (Russian), tr (Turkish), ur (Urdu), vi (Vietnamese), zh (Chinese - Simplified), ot (Other/Unknown).

The recipe in recipes/prompt_distillation/create_data.py also includes handling strategies for inputs containing code, numerical content, or multiple languages.

In the example below, the same model (Qwen/Qwen3-30B-A3B) is used as both teacher and student, though in general they need not be identical.

Step 1: Generate Training Data
Create prompt distillation data using the teacher model using recipes/prompt_distillation/create_data.py:

python -m tinker_cookbook.recipes.prompt_distillation.create_data \
  output_file=/tmp/tinker-datasets/prompt_distillation_lang.jsonl

This command will:

Use the configured teacher model to generate language classification examples
Save the distilled dataset to the specified output file
Create diverse training examples suitable for student model fine-tuning
Step 2: Train the Student Model
Fine-tune a student model on the distillation data using recipes/prompt_distillation/train.py:

python -m tinker_cookbook.recipes.prompt_distillation.train

The training script will:

Load the generated distillation dataset
Apply optimized training configurations
Fine-tune the student model for language classification
Step 3: Test Your Model
Once training is complete, you can test your distilled model by sampling from the trained model to verify its performance on language classification tasks.

Advanced Configuration
The prompt distillation recipe can be customized for different scenarios:

Teacher model selection: Choose different base models based on your requirements
Sampling strategies: Adjust temperature and other generation parameters
Data volume: Scale the number of generated examples based on your needs
Training hyperparameters: Fine-tune learning rates and other training settings
Last updated on November 20, 2025
SL hyperparams
Sweep case study
Tinker API Documentation



Sweep case study
In Supervised Learning Hyperparameters, we introduced default hyperparameters as a starting point. While defaults are useful, optimal values are often task-specific. A hyperparameter sweep---systematically testing values across a range---is a more reliable way to identify the best settings for your use case.

This guide demonstrates how to sweep over the learning rate (LR) to find an optimal value.

Why sweep the learning rate?
The learning rate is typically the most impactful hyperparameter. While our default recommendations perform well (usually <0.5% regret), you can often achieve even better results by sweeping to find the task-specific optimum.

Setup
We use the simple supervised learning training loop in sl_loop.py, which trains a Llama-3.1-8B model.

To retrieve the modelâ€™s default learning rate recommendation:

from tinker_cookbook.hyperparam_utils import get_lr
print(get_lr("meta-llama/Llama-3.1-8B"))

This should output

0.0002856415043086949  # â‰ˆ 2.8e-4

This default value provides a baseline. A common best practice is to sweep one order of magnitude above and below the default. For this case, we sweep over: 
L
R
âˆˆ
[
1
e
âˆ’
5
,
3
e
âˆ’
5
,
1
e
âˆ’
4
,
3
e
âˆ’
4
,
1
e
âˆ’
3
,
3
e
âˆ’
3
]
LRâˆˆ[1eâˆ’5,3eâˆ’5,1eâˆ’4,3eâˆ’4,1eâˆ’3,3eâˆ’3]

Running the sweep
Launch experiments in parallel, using separate terminal windows for each LR value. For example:

python -m tinker_cookbook.recipes.sl_loop learning_rate=0.003 log_path=/tmp/sft-lr-sweep/lr-0.003
python -m tinker_cookbook.recipes.sl_loop learning_rate=0.001 log_path=/tmp/sft-lr-sweep/lr-0.001
python -m tinker_cookbook.recipes.sl_loop learning_rate=0.0003 log_path=/tmp/sft-lr-sweep/lr-0.0003
python -m tinker_cookbook.recipes.sl_loop learning_rate=0.0001 log_path=/tmp/sft-lr-sweep/lr-0.0001
python -m tinker_cookbook.recipes.sl_loop learning_rate=0.00003 log_path=/tmp/sft-lr-sweep/lr-0.00003
python -m tinker_cookbook.recipes.sl_loop learning_rate=0.00001 log_path=/tmp/sft-lr-sweep/lr-0.00001

You can also automate this process by writing a script that spawns multiple tmux windows and launches experiments programmatically. This is especially useful for larger sweeps.

Collecting Results
After the experiments are complete, you can read the metrics.jsonl files:

from glob import glob
import pandas
import os
import json
 
data = []
for fname in sorted(glob(os.path.expanduser("/tmp/sft-lr-sweep/*/metrics.jsonl"))):
    df = pandas.read_json(fname, lines=True)
    # make sure the experiment is completed
    if len(df) == 0 or df["progress"].iloc[-1] < 0.98:
        continue
    config_fname = fname.replace("metrics.jsonl", "config.json")
    with open(config_fname, "rb") as f:
        metadata = json.load(f)
    data.append({
        "fname": fname,
        "learning_rate": metadata["learning_rate"],
        "final_loss": df["train_mean_nll"].iloc[-1].item()
    })
 
print(f"Read metrics for {len(data)} experiments")

If all the experiments are completed, the above code should print:

Read metrics for 6 experiments

Visualizing the Sweep
Plot the final_loss as a function of learning_rate:

import matplotlib.pyplot as plt
df = pandas.DataFrame(data)
plt.plot(df["learning_rate"], df["final_loss"], marker='o')
plt.axhline(y=df["final_loss"].min(), color="green", linestyle="--")
plt.ylim(1.65, 1.8)
plt.xscale("log")
plt.xlabel("Learning Rate (log scale)")
plt.ylabel("Final Loss")
plt.title("Final Loss vs Learning Rate")
plt.show()

You should see a U-shaped curve, similar to this:final_loss_vs_lr

If the full U-curve is not visible in your setting, expand the sweep range by adding more LR values.

Determining the Optimal LR
The optimal learning rate is the one that minimizes the loss. The plot above shows that the optimal LR is 3e-4 which you can also calculate by finding the minima:

optimal_lr = df["learning_rate"][df["final_loss"].idxmin()]
print(f"The optimal LR is {optimal_lr:.2e}")

Expected output:

The optimal LR is 3.00e-04

Note that the optimal LR in our sweep (3e-4) is very close to the default LR (2.8e-4). However, task-specific sweeps can still provide marginal improvements and greater confidence in your hyperparameter choices.

Next steps
Now that you've identified the optimal learning rate:

Retrain with the optimal LR for your production run
Consider sweeping other hyperparameters like batch size, warmup steps, or weight decay
Use the optimal LR as a baseline for future experiments on similar tasks
Last updated on November 20, 2025
Prompt distillation
Reinforcement Learning
Tinker API Documentation



Reinforcement learning
Reinforcement learning (RL) means learning from trial and error. Whereas in supervised learning, we're given input-output pairs, in RL, we're given inputs (prompts) and reward functions (i.e., a function for scoring candidate outputs). RL algorithms need to discover what good outputs look like.

Here are a few different types of RL training that we support in the Tinker Cookbook:

RL with Verifiable Rewards: this is when we do RL on a reward function that checks model outputs using a program. Typically, the reward function checks the candidate answer against a reference answer, or, in coding cases, it may check if the candidate solution passes some unit tests. RLVR is especially suitable for teaching models to do reasoning (with chain-of-thought) and multi-step tool use (e.g., debugging and iterative modification pf programs).
RL on Human Feedback: here, we assume we have an objective that can't be calculated by a simple program, and it requires some human judgement. For example, we typically want to optimize our models for helpfulness, which includes being clear, informative, and interesting. For RLHF, we train a preference model using supervised learning to match human judgement, scoring or ranking candidate outputs. Then we do RL on the preference model's scores. See the Preferences section for more details.
We'll first show how to do small RL runs in the RLVR setting, then we'll show you how to define your own RL environments and train on them, then we'll provide examples for larger-scale or more complicated training setups.

We anticipate that people will want to use Tinker for RL in a few different ways:

Creating a specialist model that's SoTA at a specific skill, which existing models haven't been trained on. In this case, you'll want to start with a post-trained model that's already strong, and then do RL on an environment you've defined. See RL Environments.
Doing research on post-training pipelines. In this case, you'll probably want to chain together SL and RL and runs with different data mixes, environments, and reward functions. See our RLHF example.
Doing research on RL algorithms. Here, you'll probably want to find some existing environments to use as benchmarks, and either modify our provided training code (rl/train.py) or write your own minimal training loop. We've provided a minimal training loop that you can use as a starting point.
Last updated on November 20, 2025
Sweep case study
Your first RL run
Tinker API Documentation


Your First RL Run
We've provided a minimal script that runs RL on the GSM8K dataset: rl_basic.py. You can run the minimal RL script from the command line as follows:

python -m tinker_cookbook.recipes.rl_basic

This script will fine-tune the Llama-3.1-8B base (pretrained) model on this dataset with the following reward function:

1
[
answer is correct
]
+
0.1
Ã—
(
1
[
answer is formatted correctly
]
âˆ’
1
)
1[answer is correct]+0.1Ã—(1[answer is formatted correctly]âˆ’1)
The training should take about 1 minute per iteration and climb to about 63% accuracy after 15 iterations (env/all/correct). You can look at the printouts for some other metrics of interest:

ac_tokens_per_turn: the number of each tokens in each generated completion
env/all/format: the fraction of completions that are formatted correctly
env/all/reward/total: mean total reward (combining format and correctness as defined above)
entropy: per-token entropy (mean negative log-probability of sampled tokens)
kl_sample_train_{v1,v2}: two different approximations/estimators of KL divergence between the sampler's and learner's probability distribution (contributed to by numerical differences and rounding noise)
progress/done_frac: what fraction of the total number of iterations we've completed so far
time/...: time for different parts of the training loop
You can also look at the log_path directory for more detailed metrics. There are several files of interest, which are mostly the same as in the Supervised Learning case.

Last updated on November 20, 2025
Reinforcement Learning
RL envs
Tinker API Documentation



RL Environments
Here, we'll explain how to create your own RL environments and train on them. First, lets look at the basic classes, which can be found in tinker_cookbook.rl.types. As you can see, there's an Env interface, corresponding to an RL environment. To write an environment, you need to implement two methods: initial_observation and step.

class Env:
    """
    Stateful environment that a single agent interacts with.
    Discard after running for one episode.
    """
 
    async def initial_observation(self) -> tuple[Observation, StopCondition]:
        raise NotImplementedError
 
    async def step(self, action: Action) -> StepResult:
        raise NotImplementedError

Note that this Env operates on tokens, rather than strings or messages. Why define it this way, when it's usually more natural to define the logic in terms of strings or messages? We've defined Env this way because this interface is what's needed by the training code, which needs to know the exact tokens that were sampled, and their logprobs.

We need to write two more small classes to use this environment in the RL training code. First, since the environment is discarded after a single episode, we need to be able to instantiate new environments in the training loop. We actually build a group of environments at a time, which enables multi-agent training or objectives that compare multiple samples (for example, a reward model that acts on a pair of samples).

class EnvGroupBuilder:
    """
    Builds a group of environments.
    """
 
    async def make_envs(self) -> Sequence[Env]:
        raise NotImplementedError

This object creates a group of environments. Often it does the trivial thing of returning a list of copies of the same environment.

Finally, we need a dataset of these EnvGroupBuilders.

class RLDataset:
    """
    Dataset of EnvGroupBuilders.
    """
 
    def get_batch(self, index: int) -> list[EnvGroupBuilder]:
        raise NotImplementedError

That's a lot of classes! But their combination gives us a lot of flexibility. In previous implementations (like OpenAI Gym), the dataset is implicitly part of the environment; this structure is more modular and gives us more control over the data loading.

Building a simple example
You can find an example of writing a new RL environment in the Twenty Questions directory. Here, we define a multi-step environment, where we're training a question-asking agent, which asks questions to another agent to guess a hidden word. In this case, the answerer model is fixed and is Llama-3.1-8B-Instruct. The player model (which we fine-tune) is also based on that same model.

You can run the training script as follows:

python -m tinker_cookbook.recipes.twenty_questions.train

Last updated on November 20, 2025
Your first RL run
RL training loop
Tinker API Documentation



Reinforcement Learning Training Loop
We've provided a simple RL training loop in rl_loop.py, which avoids using our environment classes and instead defines the data loading and rollouts in a more self-contained way. This is for people who like to write their own training loops or learn about how things work under the hood. Our more performant implementation in rl/train.py does basically the same thing, but with some performance optimizations, and with some additional features like periodic evals.

You can run the RL training loop using:

python -m tinker_cookbook.recipes.rl_loop

The default config should write the results to /tmp/tinker-examples/rl-loop. The experiment should be completed after 57 steps of training. You can plot the reward curve as follows:

import pandas
import matplotlib.pyplot as plt
 
metrics_path = "/tmp/tinker-examples/rl-loop/metrics.jsonl"
df = pandas.read_json(metrics_path, lines=True)
plt.plot(df["reward/mean"], label="reward/mean")
plt.legend()
plt.show()

You should see a plot like this:Reward as a function of steps

Last updated on November 20, 2025
RL envs
RL hyperparams
Tinker API Documentation



RL Hyperparameters
This guide covers the key hyperparameters for reinforcement learning training, from core settings to advanced configurations.

Core Hyperparameters
Learning Rate
Similar to the supervised learning setting, the learning rate is the most critical hyperparameter choice. We recommend using the guidance presented there as a starting point for RL experiments as well.

Batch and Group Sizes
As described in our RL environments documentation, we use two key parameters:

batch_size: The number of unique environments or problems used for training
group_size: The number of rollouts performed per unique environment
If you have limited environments or problems available for training, increase the group_size to generate more training data. While the total number of rollouts depends on both parameters, we recommend scaling learning rates proportionally to 
LR
âˆ
batch_size
LRâˆ 
batch_size
â€‹
 .

Multiple Updates per Sampling Iteration
The num_substeps parameter controls how many policy weight updates are performed on data sampled from the last policy iteration, similar to PPO and GRPO.

How it works:
num_substeps = 1 (default): Each batch of collected trajectories is used for exactly one optimizer update
num_substeps > 1: The batch of unique environments is split into num_substeps mini-batches, where each environment/problem has group_size rollouts (we pack all rollouts for a particular environment/problem in the same minibatch). We do a single update step on each mini-batch. Note that our implementation still takes only a single epoch through the data.
Usage Guidelines:
The batch size must be divisible by num_substeps
Our experiments show that num_substeps = 1 already gives decent performance, but if you would like to experiment with this parameter, we recommend starting with a low value of 2-4 and using the PPO objective.
Higher values can lead to update steps that are too out-of-distribution for the policy. Consider limiting the number of updates or decreasing the learning rate when using multiple update steps.
Advanced Training Configurations
âš ï¸ Note: These features are experimental and may be subject to instabilities. They are currently disabled by default.

Streaming Minibatch Training
Enable streaming minibatch training by specifying the StreamMinibatchConfig. This approach overlaps trajectory sampling and model training, improving overall throughput by submitting training requests as soon as enough rollouts complete, without waiting for all sampling jobs to finish.

Configuration Parameters:

groups_per_batch: Same as batch size
num_minibatches: Number of minibatches per substepâ€”controls how many individual forward-backward requests we submit. This controls how the work is split.
Important: This remains on-policy training and is strictly a pipeline efficiency improvement.

Async Off-Policy Training
Async training allows the model to train on trajectories generated with slightly older model versions, enabling higher throughput at the cost of some off-policy bias. While Tinker doesn't currently support in-flight weight changes, it supports the "off-by-K" async RL approach where multiple model iterations generate data simultaneously. Configure this by setting the AsyncConfig object.

Configuration Parameters:

max_steps_off_policy: Maximum age (in training steps) of trajectories before they're discarded. Essentially, trajectories from policy iterations older than max_steps_off_policy steps will not be used.
groups_per_batch: Number of new trajectory groups to accumulate (with a group_size number of rollouts each) before updating the current iteration of the model. Note: This is separate from the batch size used for dataset construction.
Usage Guidelines:

Async RL is appropriate for applications with long and heterogeneous rollouts, such as very long CoT models, multi-hop tool use, or agentic workflows
Start with a small value for max_steps_off_policy (less than 5)
Monitoring and Run Health
Using policy-gradient algorithms with off-policy data can significantly degrade performance or even crash the policy, making monitoring essential during training.

KL Divergence Monitoring
The current implementation logs the KL divergence between the data generation policy and the current learner: 
D
K
L
[
Ï€
sampler
(
â‹…
âˆ£
x
)
âˆ£
âˆ£
Ï€
Î¸
(
â‹…
âˆ£
x
)
]
D 
KL
â€‹
 [Ï€ 
sampler
â€‹
 (â‹…âˆ£x)âˆ£âˆ£Ï€ 
Î¸
â€‹
 (â‹…âˆ£x)] using two separate estimators (Schulman 2020):

kl_sample_train_v1
kl_sample_train_v2
A few important notes to keep in mind:

Even with full on-policy training, the divergence between sampling and learning policies will not be exactly zero (He 2025) due to implementation details
In our experience training is stable with KL divergence below 0.01
If KL divergence crosses a recommended threshold, this indicates a numerical instability or potential issue with the training run
Last updated on November 20, 2025
RL training loop
Preferences
Tinker API Documentation



Preferences
Learning from Preferences
In this section, we focus on learning from pairwise feedback, where we have preference data indicating which of two completions is better for a given prompt. This kind of feedback is a natural fit for tasks where there's not a simple correctness criterion that can be computed programmatically. These preferences might be collected from human evaluators or generated bya model.

Two Approaches to Preference Learning
When you have pairwise preference data, there are two main approaches:

Direct Preference Optimization (DPO): Directly update the policy to prefer chosen responses over rejected ones, without needing a separate reward model. This is simpler and computationally cheaper. See the DPO Guide for details.

Reinforcement Learning from Human Feedback (RLHF): Train a reward model on preference data, then use reinforcement learning to optimize the policy against this reward model. This two-stage approach provides more flexibility. See the the RLHF example for details.

Last updated on November 20, 2025
RL hyperparams
DPO guide
Tinker API Documentation


Direct Preference Optimization (DPO)
Direct Preference Optimization (DPO) is a method for training language models to align with human preferences without requiring a separate reward model. Instead of using reinforcement learning with human feedback (RLHF), DPO directly optimizes the model to prefer chosen responses over rejected ones using a simple classification loss.

DPO Algorithm Details
The core DPO loss is computed as:

L
Î¸
=
âˆ’
E
x
,
y
chosen
,
y
rejected
âˆ¼
D
[
log
â¡
Ïƒ
(
Î²
log
â¡
Ï€
Î¸
(
y
chosen
âˆ£
x
)
Ï€
ref
(
y
chosen
âˆ£
x
)
âˆ’
Î²
log
â¡
Ï€
Î¸
(
y
rejected
âˆ£
x
)
Ï€
ref
(
y
rejected
âˆ£
x
)
)
]
L 
Î¸
â€‹
 =âˆ’E 
x,y 
chosen
â€‹
 ,y 
rejected
â€‹
 âˆ¼D
â€‹
 [logÏƒ(Î²log 
Ï€ 
ref
â€‹
 (y 
chosen
â€‹
 âˆ£x)
Ï€ 
Î¸
â€‹
 (y 
chosen
â€‹
 âˆ£x)
â€‹
 âˆ’Î²log 
Ï€ 
ref
â€‹
 (y 
rejected
â€‹
 âˆ£x)
Ï€ 
Î¸
â€‹
 (y 
rejected
â€‹
 âˆ£x)
â€‹
 )]
Where:

Ï€
Î¸
Ï€ 
Î¸
â€‹
  is the current policy
Ï€
ref
Ï€ 
ref
â€‹
  is the reference model (typically the initial model before DPO training)
Î²
Î² is the DPO beta parameter
Where 
D
D is a dataset of prompts 
x
x, a chosen response 
y
chosen
y 
chosen
â€‹
  and a rejected response 
y
rejected
y 
rejected
â€‹
 
This optimizes the classical constrianed RLHF objective, where the reference model constrains deviation from the initial distribution.

DPO vs RLHF: DPO eliminates the need for a separate reward model by directly optimizing the policy to prefer chosen responses. This makes training simpler and computationally cheaper than classical RLHF.

Running DPO Training
The implementation is in train_dpo.py with a CLI interface in train.py. You can run it from the command line:

python -m tinker_cookbook.recipes.preference.train \
    log_path=/tmp/dpo-hhh-experiment \
    model_name=meta-llama/Llama-3.2-1B \
    dataset=hhh \
    renderer_name=role_colon \
    learning_rate=1e-5 \
    dpo_beta=0.1

Key Parameters
log_relpath: Directory where results and checkpoints are saved
model_name: Base model used as initialization and for the reference policy
dataset: Dataset name (hhh, helpsteer3, ultrafeedback)
renderer_name: How conversations are formatted (see Rendering)
learning_rate: Learning rate for optimization
dpo_beta: DPO beta parameter (controls the strength of preference learning)
Available Datasets
There are several pre-defined datasets:

hhh: Anthropic's Helpful-Harmless-Honest dataset
helpsteer3: NVIDIA's HelpSteer3 preference dataset
ultrafeedback: UltraFeedback binarized preferences dataset
These are implemented as DPODatasetBuilder classes and you can implement a custom dataset builder following the tinker_cookbook.preference.preference_datasets interface.

Training Process
During training, you'll see output like this showing the DPO metrics:

                   Step 50                    
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”³â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ Metric                         â”ƒ Value     â”ƒ
â”¡â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•‡â”â”â”â”â”â”â”â”â”â”â”â”©
â”‚ accuracy                       â”‚ 0.568627  â”‚
â”‚ batch_time                     â”‚ 27.953704 â”‚
â”‚ chosen_reward                  â”‚ 0.053621  â”‚
â”‚ dpo_loss                       â”‚ 0.683825  â”‚
â”‚ learning_rate                  â”‚ 0.000009  â”‚
â”‚ margin                         â”‚ 0.002147  â”‚
â”‚ num_pairs                      â”‚ 255       â”‚
â”‚ num_tokens                     â”‚ 112638    â”‚
â”‚ progress                       â”‚ 0.081210  â”‚
â”‚ rejected_reward                â”‚ 0.032152  â”‚
â”‚ test/nll                       â”‚ 1.871778  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

The key metrics are:

dpo_loss: The DPO classification loss
accuracy: Accuracy of the implicit reward model evaluated on the preference dataset
margin: Average difference between chosen and rejected rewards
chosen_reward/rejected_reward: Average rewards for chosen/rejected responses
Evaluating DPO Models
After training, you can evaluate your DPO model using the inspect evaluation framework:

MODEL_PATH=tinker://YOUR_MODEL_PATH_HERE
python -m tinker_cookbook.eval.run_inspect_evals \
    model_path=$MODEL_PATH \
    model_name=meta-llama/Llama-3.2-1B \
    tasks=inspect_evals/ifeval \
    renderer_name=role_colon

This will evaluate the model on various benchmarks to measure the impact of preference optimization.

Tips for DPO Training
Beta Parameter: Start with dpo_beta=0.1 and adjust based on your dataset.

Learning Rate: Use a lower learning rate than supervised fine-tuning (typically 1e-5 to 1e-6).

Base Model: The base model should already be in-distribution with the preference data. Either start with a ligh SFT phase or collect on-policy preferences. While training would still work. sharp distribution mis-match will create strange model behaviors.

Last updated on November 20, 2025
Preferences
RLHF worked example
Tinker API Documentation



Reinforcement Learning from Human Feedback
We've provided a script that shows how to run a standard pipeline for reinforcement learning from human feedback (RLHF) in rlhf_pipeline.py.

python -m recipes.preference.rlhf.rlhf_pipeline

Training the initial policy via supervised learning
First, we train the policy on the no_robots dataset from Huggingface, which is a basic instruction following dataset with human-written answers, which was designed to match the methodology from InstructGPT.

Training the preference model via supervised learning
We train the preference model on the HHH dataset from Anthropic, which is a dataset of pairwise comparisons of completions. We train a model that sees a pair of completions, A and B, and outputs which one is preferred.

Training the policy via reinforcement learning
Taking the initial policy, and the preference model we just trained, we can now train the policy via reinforcement learning. This RL is a form of self-play, where we use the preference model to grade match-ups between the policy and itself. In particular, for each prompt, we sample multiple completions, and use the preference model to grade all pairs of completions. We then give the policy a reward based on the win fraction.

Last updated on November 20, 2025
DPO guide
Evaluations
Tinker API Documentation



Evaluations
Our training scripts will print out training and test loss. Two common workflows for evaluations are to do inline evals during training and to do offline evals on various checkpoints from a run.

Inline Evals
You can add inline evaluations to your training runs by configuring evaluator builders in advance for both supervised fine-tuning and RL training jobs.

Supervised Fine-Tuning (supervised.train)
Add one or both of the following to your config:

evaluator_builders: list[EvaluatorBuilder] - Runs evaluations every eval_every steps
infrequent_evaluator_builders: list[EvaluatorBuilder] - Runs evaluations every infrequent_eval_every steps
RL Training (rl.train)
Add the following to your config:

evaluator_builders: list[SamplingClientEvaluator] - Runs evaluations every eval_every steps
For implementation guidance and a detailed example, see here and here respectively.

Offline evals
We support and recommend several ways for creating and running your offline evaluations on your model checkpoints.

Running Standard Evaluations with Inspect AI.
We support running many of the standard cited evaluations using the Inspect AI library.

We have provided a script to evaluate models using Tinker's internal sampling functionality as shown below.

MODEL_PATH=tinker://FIXME # YOUR MODEL PATH HERE
python -m tinker_cookbook.eval.run_inspect_evals \
    model_path=$MODEL_PATH \
    model_name=MODEL_NAME \ # YOUR MODEL_NAME HERE
    tasks=inspect_evals/ifeval,inspect_evals/mmlu_0_shot \
    renderer_name=RENDERER_NAME # YOUR RENDERER_NAME HERE

Click here to view additional supported evaluations.

Creating your own Sampling Evaluations
We recommend two ways to create your own evaluations:

creating your own tasks with Inspect AI and running like above
creating your own SamplingClientEvaluator
Create tasks with Inspect AI
In addition to passing in standard evaluations, you can create your own tasks using inspect ai as detailed here.

Here is a toy example of how to create an evaluation with an LLM-as-a-judge where we use a model produced by tinker as a grader.

import tinker
from inspect_ai import Task, task
from inspect_ai.dataset import MemoryDataset, Sample
from inspect_ai.model import GenerateConfig as InspectAIGenerateConfig
from inspect_ai.model import Model as InspectAIModel
from inspect_ai.scorer import model_graded_qa
from inspect_ai.solver import generate
from tinker_cookbook.eval.inspect_utils import InspectAPIFromTinkerSampling
 
QA_DATASET = MemoryDataset(
    name="qa_dataset",
    samples=[
        Sample(
            input="What is the capital of France?",
            target="Paris",
        ),
        Sample(
            input="What is the capital of Italy?",
            target="Rome",
        ),
    ],
)
 
service_client = tinker.ServiceClient()
sampling_client = service_client.create_sampling_client(
    base_model="meta-llama/Llama-3.1-8B-Instruct"
)
 
api = InspectAPIFromTinkerSampling(
    renderer_name="llama3", 
    model_name="meta-llama/Llama-3.1-8B-Instruct",
    sampling_client=sampling_client,
    verbose=False,
)
 
GRADER_MODEL = InspectAIModel(api=api, config=InspectAIGenerateConfig())
 
 
@task
def example_lm_as_judge() -> Task:
    """
    Example task using LLM-as-a-judge scoring.
 
    Note: The grader model defaults to the model being evaluated.
    To use a different grader model, specify it with --model-grader when using inspect directly.
    """
    return Task(
        name="llm_as_judge",
        dataset=QA_DATASET,
        solver=generate(),
        scorer=model_graded_qa(
            instructions="Grade strictly against the target text as general answer key and rubric. "
            "Respond 'GRADE: C' if correct or 'GRADE: I' otherwise.",
            partial_credit=False,
            # model parameter is optional - if not specified, uses the model being evaluated
            model=GRADER_MODEL,
        ),
    )

Inspect also natively supports replacing our GRADER_MODEL with any openai-chat-completion style api (e.g. openrouter).

Create your own SamplingClientEvaluator
Alternatively, you can create your own SamplingClientEvaluator class instead of using Inspect AI. This is a lower level abstraction than the above with finer-grain control over running your evaluations.

We expose this to interace to allow users more control over their datasets and metrics. To illustrate, see this custom evaluators example of how one might create their own complex SamplingClientEvaluator.

For a more illustrative toy instructive example see below.

from typing import Any, Callable
 
import tinker
from tinker import types
 
from tinker_cookbook import renderers
from tinker_cookbook.evaluators import SamplingClientEvaluator
from tinker_cookbook.tokenizer_utils import get_tokenizer
 
class CustomEvaluator(SamplingClientEvaluator):
    """
    A toy SamplingClientEvaluator that runs a custom evaluation and returns its metrics.
    """
 
    def __init__(
        self, 
        dataset: Any, 
        grader_fn: Callable[[str, str], bool],
        model_name: str,
        renderer_name: str,
    ):
        """
        Initialize the CustomEvaluator.
        Args:
            config: Configuration object containing all evaluation parameters
        """
        self.dataset = dataset
        self.grader_fn = grader_fn
 
        tokenizer = get_tokenizer(model_name)
        self.renderer = renderers.get_renderer(name=renderer_name, tokenizer=tokenizer)
 
    async def __call__(self, sampling_client: tinker.SamplingClient) -> dict[str, float]:
        """
        Run custom evaluation on the given sampling client and return metrics.
        Args:
            sampling_client: The sampling client to evaluate
        Returns:
            Dictionary of metrics from inspect evaluation
        """
 
        metrics = {}
 
        num_examples = len(self.dataset)
        num_correct = 0
 
        sampling_params = types.SamplingParams(
            max_tokens=100,
            temperature=0.7,
            top_p=1.0,
            stop=self.renderer.get_stop_sequences(),
        )
 
        for datum in self.dataset:
            model_input: types.ModelInput = self.renderer.build_generation_prompt(
                [renderers.Message(role="user", content=datum["input"])]
            )
            # Generate response
            r: types.SampleResponse = await sampling_client.sample_async(
                prompt=model_input, num_samples=1, sampling_params=sampling_params
            )
            tokens: list[int] = r.sequences[0].tokens
            response: renderers.Message = self.renderer.parse_response(tokens)[0]
            if self.grader_fn(response["content"], datum["output"]):
                num_correct += 1
 
        metrics["accuracy"] = num_correct / num_examples
        return metrics

Here is an example of how we can use the above CustomEvaluator on a toy dataset and grader.

QA_DATASET = [
    {"input": "What is the capital of France?", "output": "Paris"},
    {"input": "What is the capital of Germany?", "output": "Berlin"},
    {"input": "What is the capital of Italy?", "output": "Rome"},
]
 
def grader_fn(response: str, target: str) -> bool:
    return target.lower() in response.lower()
 
evaluator = CustomEvaluator(
    dataset=QA_DATASET,
    grader_fn=grader_fn,
    renderer_name="llama3",
    model_name="meta-llama/Llama-3.1-8B-Instruct",
    
)
 
service_client = tinker.ServiceClient()
sampling_client = service_client.create_sampling_client(base_model="meta-llama/Llama-3.1-8B-Instruct")
 
async def main():
    result = await evaluator(sampling_client)
    print(result)
 
asyncio.run(main())

Last updated on November 20, 2025
RLHF worked example
Completers
Tinker API Documentation


Completers
The concept of policies is crucial to the RL training process. In the Tinker Cookbook, policies are implemented as Completers. Completers are abstractions that represent models or policies that can be sampled from, providing different levels of structure depending on your use case.

Overview of Completer Types
The Tinker Cookbook provides two main types of completers, each designed for different use cases:

TokenCompleter: Operates on tokens and is used by RL algorithms
MessageCompleter: Operates on messages and needs to be used with a renderer
The choice between these depends on whether you're working at the token level for RL training or at the message level for interacting with and evaluating the model.

TokenCompleter
The TokenCompleter is the foundational interface used by RL algorithms because they work directly with tokens.

class TokenCompleter:
    async def __call__(
        self, model_input: types.ModelInput, stop: StopCondition
    ) -> TokensWithLogprobs:

This interface takes:

model_input: The input to the model (of type types.ModelInput)
stop: Stop conditions, either a list of strings or token IDs (combined into a StopCondition class). When training with reinforcement learning, this should be defined by the initial_observation function of the environment.
It returns a TokensWithLogprobs object containing:

tokens: The generated token sequence
maybe_logprobs: Optional log probabilities for each token
MessageCompleter
The MessageCompleter operates at a higher level with structured messages, similarly to standard chat APIs. It takes a list of messages and returns a single assistant message response.

class MessageCompleter:
    async def __call__(self, messages: list[renderers.Message]) -> renderers.Message:

For training purposes the TokenCompleter is the class we will use for RL training as we need to optimize the same same set of tokens during the update step that the model output during rollout. The MessageCompleter is useful for sampling where we need to use the model output for semantic purposes such as Judge models or multi-agent environments.

The Tinker Cookbook uses two concrete implementations of these interfaces - TinkerTokenCompleter and TinkerMessageCompleter which are both wrappers around a tinker.SamplingClient. While the TinkerTokenCompleter operates directly on tokens, the TinkerMessageCompleter needs to be instantiated with a renderer to make it compatible with the inputs expected by the samping client.

Last updated on November 20, 2025
Evaluations
Under the Hood
Tinker API Documentation

Under the Hood
This page explains some implementation details of Tinker, which are important for understanding how to speed up your code.

Clock Cycles
In Tinker, after you call ServiceClient.create_lora_training_client, your training job gets assigned to a pool of machines that working together -- a worker pool -- which are doing forward-backward operations repeatedly in lock-step. Each of these steps of the worker pool is called a clock cycle. In each clock cycle, we do forward-backward and an optimizer step operation, each of which may involve multiple LoRA models that are being trained by this pool. You can think of this pool as a single large training run that is time-shared between multiple different LoRA models, often from different users.

With multi-tenancy -- sharing the same worker pool between multiple models -- we can run the training system efficiently even if users are training with small batch sizes, or if they have other delays in their training loops that would otherwise leave the worker pool idle. Small batch sizes can often give better sample efficiency, so this setup lets us achieve both high compute efficiency and high sample efficiency.

The downside is that it can sometimes lead to worse latency: even if training with a small batch, you'll still see the same step time as a large batch. (Still, note that we'll only charge you for the compute you use.) Also, if your training loop is implemented naively, you might have to wait multiple clock cycles per batch, because you might miss a clock cycle between operations.

Overlapping forward_backward and optim_step Requests
As mentioned in the Async and Futures section, you should submit your forward_backward and optim_step requests together before waiting for either of them. This way, they'll end up on the same clock cycle. If you write the code naively, you'll end up using three clock cycles per training step. Here's a recap of the example from the Async and Futures section:

âŒ Naive implementation (uses 3 clock cycles):

# Submit forward_backward, gets queued for clock cycle N
fwd_bwd_future = await client.forward_backward_async(batch, loss_fn)
 
# Wait for it to complete, and for client to receive the result
# Due to communication latency, this happens a little after cycle N+1 started
fwd_bwd_result = await fwd_bwd_future
 
# Submit optim_step, gets queued for clock cycle N+2
optim_future = await client.optim_step_async(adam_params)
 
# Wait for it to complete, and for client to receive the result
# This happens a little after cycle N+2 finishes
optim_result = await optim_future
 
# Total: forward_backward on cycle N, optim_step on cycle N+2
# This takes 3 clock cycles (plus the time we waited before cycle N started)

âœ“ Better implementation (uses 1 clock cycle):

# Submit both requests immediately. They'll both be slotted into the same clock cycle N
fwd_bwd_future = await client.forward_backward_async(batch, loss_fn)
optim_future = await client.optim_step_async(adam_params)
 
# Now wait for results - both operations happen on cycle N
fwd_bwd_result = await fwd_bwd_future
optim_result = await optim_future
 
# Total: both operations on cycle N
# This takes 1 clock cycle

Pipelining to Maximize Clock Cycle Efficiency
To maximize efficiency and avoid missing clock cycles, you should pipeline your training loop: submit the next batch before waiting for the current batch to complete. This ensures there's always a request queued when a new clock cycle starts.

We've created a demonstration script that shows the difference between pipelined and non-pipelined training:

View the clock cycles demonstration script â†’

The script includes two versions:

Non-pipelined: Submits a batch, waits for it to complete, then submits the next. This approach typically wastes clock cycles because there's a gap between when one batch finishes and the next is submitted, often using 2 clock cycles per training step.

Pipelined: Submits the next batch before waiting for the previous batch to complete. This approach often uses exactly 1 clock cycle per step, achieving maximum efficiency. Though it might sometimes take more than 1 clock cycle per step if the server is heavily loaded, or due to subtleties of our current implementation. (For example, if there are no other users, we might start the clock cycle after receiving the first forward_backward but before receiving the optim_step. Then we'll do optim_step on the next cycle. This causes an extra clock cycle but doesn't cause a slowdown.)

Running the script will show you the performance comparison, including total time and clock cycles used. The pipelined version typically saves both time and clock cycles.

Last updated on November 20, 2025
Completers
Dev Tips
Tinker API Documentation




